<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Megh&#39;s Blog</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://meghprkh.github.io/blog/"/>
  <updated>2016-07-10T19:48:31.074Z</updated>
  <id>https://meghprkh.github.io/blog/</id>
  
  <author>
    <name>Megh Parikh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adventures with the Meson Build System and a GTK Playground</title>
    <link href="https://meghprkh.github.io/blog/2016/07/11/Adventures-with-the-Meson-Build-System-and-a-GTK-Playground/"/>
    <id>https://meghprkh.github.io/blog/2016/07/11/Adventures-with-the-Meson-Build-System-and-a-GTK-Playground/</id>
    <published>2016-07-10T19:30:04.000Z</published>
    <updated>2016-07-10T19:48:31.074Z</updated>
    
    <content type="html">&lt;p&gt;This post describes some of my experience with the &lt;a href=&quot;http://mesonbuild.com/&quot; title=&quot;Meson Build&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Meson Build&lt;/a&gt; system. Also I have created a playground for GTK which I use to create simple protoypes with some functionality. The really nice thing about Meson is its &lt;em&gt;python-ish&lt;/em&gt;/&lt;em&gt;lua-ish&lt;/em&gt; syntax. The other thing is that it is &lt;em&gt;really&lt;/em&gt; fast.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;My-experience&quot;&gt;&lt;a href=&quot;#My-experience&quot; class=&quot;headerlink&quot; title=&quot;My experience&quot;&gt;&lt;/a&gt;My experience&lt;/h2&gt;&lt;p&gt;As a newbie I found Automake unfriendly (maybe because of its primitive m4 macro system). So I was looking for something quick to learn for building my &lt;a href=&quot;https://github.com/meghprkh/libgamepad&quot; title=&quot;LibGamepad&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LibGamepad&lt;/a&gt; library. Initially I opted for the awesome &lt;a href=&quot;https://github.com/rastersoft/autovala&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Autovala&lt;/a&gt;. But then I realized that while super-easy, it was not flexible. I wanted conditional compilation (per-platform) but could not do it. Then while I was looking at the &lt;a href=&quot;https://cmake.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMake&lt;/a&gt; files generated by Autovala, they too felt kind of cryptic, so I decided to start from scratch and write the CMake files on my own. Still even CMake’s syntax was kind of weird and &lt;em&gt;macro-ish&lt;/em&gt;. Then I tried a hand at Meson. Surprisingly I was able to easily build simple Vala programs without giving it much time.&lt;/p&gt;
&lt;h2 id=&quot;The-neat-language&quot;&gt;&lt;a href=&quot;#The-neat-language&quot; class=&quot;headerlink&quot; title=&quot;The neat language&quot;&gt;&lt;/a&gt;The neat language&lt;/h2&gt;&lt;p&gt;In Meson, you feel like you are interacting with a higher-order language. You get immutable arrays and strings. Your interaction with the compiler modules is through objects. In short, &lt;em&gt;its just amazing&lt;/em&gt;. I could have elaborated this section and written some features, but then you can find it on the &lt;a href=&quot;https://github.com/mesonbuild/meson/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Meson Wiki&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Some-reference-links&quot;&gt;&lt;a href=&quot;#Some-reference-links&quot; class=&quot;headerlink&quot; title=&quot;Some reference links&quot;&gt;&lt;/a&gt;Some reference links&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tutorial: &lt;a href=&quot;https://github.com/mesonbuild/meson/wiki/Tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mesonbuild/meson/wiki/Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Indepth Tutorial: &lt;a href=&quot;https://github.com/mesonbuild/meson/wiki/IndepthTutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mesonbuild/meson/wiki/IndepthTutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vala example: &lt;a href=&quot;https://github.com/mesonbuild/meson/wiki/Vala&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mesonbuild/meson/wiki/Vala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GNOME module: &lt;a href=&quot;https://github.com/mesonbuild/meson/wiki/Gnome-module&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mesonbuild/meson/wiki/Gnome-module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Reference Manual: &lt;a href=&quot;https://github.com/mesonbuild/meson/wiki/Reference-Manual&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mesonbuild/meson/wiki/Reference-Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Note&lt;/em&gt;: On Fedora it is &lt;code&gt;ninja-build&lt;/code&gt; and not &lt;code&gt;ninja&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;A-GTK-Playground-A-starter-kit&quot;&gt;&lt;a href=&quot;#A-GTK-Playground-A-starter-kit&quot; class=&quot;headerlink&quot; title=&quot;A GTK Playground / A starter kit&quot;&gt;&lt;/a&gt;A GTK Playground / A starter kit&lt;/h2&gt;&lt;p&gt;Ever want to prototype some mockup without fiddling with your main application? I created a small playground which I use for creating prototypes &lt;a href=&quot;https://github.com/meghprkh/valagtk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/meghprkh/valagtk&lt;/a&gt; . You can simply open &lt;a href=&quot;https://glade.gnome.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Glade&lt;/a&gt;, create your prototype and add some interactivity using &lt;a href=&quot;https://blogs.gnome.org/tvb/2013/05/29/composite-templates-lands-in-vala/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GtkTemplate&lt;/a&gt; in your Vala code and BOOM! This uses the Meson build system to give you an easy-to-extend starter along with super-fast builds.&lt;/p&gt;
&lt;p&gt;Please leave your comments in the comments section =).&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;This post describes some of my experience with the &lt;a href=&quot;http://mesonbuild.com/&quot; title=&quot;Meson Build&quot;&gt;Meson Build&lt;/a&gt; system. Also I have created a playground for GTK which I use to create simple protoypes with some functionality. The really nice thing about Meson is its &lt;em&gt;python-ish&lt;/em&gt;/&lt;em&gt;lua-ish&lt;/em&gt; syntax. The other thing is that it is &lt;em&gt;really&lt;/em&gt; fast.&lt;/p&gt;
    
    </summary>
    
      <category term="Opensource" scheme="https://meghprkh.github.io/blog/categories/Opensource/"/>
    
    
      <category term="GNOME" scheme="https://meghprkh.github.io/blog/tags/GNOME/"/>
    
      <category term="Meson Build" scheme="https://meghprkh.github.io/blog/tags/Meson-Build/"/>
    
  </entry>
  
  <entry>
    <title>GSoC - Progress so far</title>
    <link href="https://meghprkh.github.io/blog/2016/06/26/GSoC-Progress-so-far/"/>
    <id>https://meghprkh.github.io/blog/2016/06/26/GSoC-Progress-so-far/</id>
    <published>2016-06-26T13:28:22.000Z</published>
    <updated>2016-07-10T18:25:27.659Z</updated>
    
    <content type="html">&lt;p&gt;My project is about adding gamepad support to GNOME Games. This means that soon you would be able to play your favorite retro games using a gamepad!&lt;/p&gt;
&lt;p&gt;Currently you can plugin a gamepad and it will just work! The app will automatically detect it and allow you to play your favorite game using the gamepad. Support for playing multiplayer games is also there. The Games branch which supports gamepads can be found &lt;a href=&quot;https://github.com/meghprkh/gnome-games/tree/dirty/feature/gamepad-incremental&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;How-its-being-done&quot;&gt;&lt;a href=&quot;#How-its-being-done&quot; class=&quot;headerlink&quot; title=&quot;How its being done&quot;&gt;&lt;/a&gt;How its being done&lt;/h2&gt;&lt;p&gt;To integrate gamepads a library was made. While currently this library is being developed as part of the GNOME Games codebase. Its developed under a different namespace. You can find the library code &lt;a href=&quot;https://github.com/meghprkh/libgamepad&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;here&lt;/a&gt;. Please note that the API of this library is &lt;em&gt;unstable&lt;/em&gt; and will keep changing.&lt;/p&gt;
&lt;p&gt;This library is a small GLib-based library that is written in Vala and aims to be easy to use. While the long-term goal is to be cross-platform, currently it supports Linux only.&lt;/p&gt;
&lt;p&gt;The gamepad mapping format used is compatible with the &lt;a href=&quot;https://github.com/gabomdq/SDL_GameControllerDB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SDL mappings&lt;/a&gt;. This means that you would be able to use many gamepads without requiring to configure them.&lt;/p&gt;
&lt;h2 id=&quot;What’s-there-in-the-future&quot;&gt;&lt;a href=&quot;#What’s-there-in-the-future&quot; class=&quot;headerlink&quot; title=&quot;What’s there in the future?&quot;&gt;&lt;/a&gt;What’s there in the future?&lt;/h2&gt;&lt;p&gt;After some more cleanup, this code will hopefully be merged into the Games codebase. After that I will focus on adding UI for features like easy-assigning of gamepads to ports and remapping the gamepad.&lt;/p&gt;
&lt;p&gt;I will keep posting updates on this blog. Stay tuned!&lt;/p&gt;
&lt;h2 id=&quot;Related-posts&quot;&gt;&lt;a href=&quot;#Related-posts&quot; class=&quot;headerlink&quot; title=&quot;Related posts&quot;&gt;&lt;/a&gt;Related posts&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2016/05/23/GSoC-2016-Introduction/&quot; title=&quot;GSoC 2016: Introduction&quot;&gt;GSoC 2016: Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2016/06/03/Handling-joysticks-and-gamepads-in-linux/&quot; title=&quot;Handling joysticks and gamepads in linux&quot;&gt;Handling joysticks and gamepads in linux&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;My project is about adding gamepad support to GNOME Games. This means that soon you would be able to play your favorite retro games using a gamepad!&lt;/p&gt;
&lt;p&gt;Currently you can plugin a gamepad and it will just work! The app will automatically detect it and allow you to play your favorite game using the gamepad. Support for playing multiplayer games is also there. The Games branch which supports gamepads can be found &lt;a href=&quot;https://github.com/meghprkh/gnome-games/tree/dirty/feature/gamepad-incremental&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Opensource" scheme="https://meghprkh.github.io/blog/categories/Opensource/"/>
    
    
      <category term="GNOME" scheme="https://meghprkh.github.io/blog/tags/GNOME/"/>
    
      <category term="GSoC" scheme="https://meghprkh.github.io/blog/tags/GSoC/"/>
    
      <category term="Gamepad" scheme="https://meghprkh.github.io/blog/tags/Gamepad/"/>
    
      <category term="Library" scheme="https://meghprkh.github.io/blog/tags/Library/"/>
    
      <category term="Games" scheme="https://meghprkh.github.io/blog/tags/Games/"/>
    
      <category term="GNOME Games" scheme="https://meghprkh.github.io/blog/tags/GNOME-Games/"/>
    
  </entry>
  
  <entry>
    <title>Handling joysticks and gamepads in linux</title>
    <link href="https://meghprkh.github.io/blog/2016/06/03/Handling-joysticks-and-gamepads-in-linux/"/>
    <id>https://meghprkh.github.io/blog/2016/06/03/Handling-joysticks-and-gamepads-in-linux/</id>
    <published>2016-06-03T16:58:52.000Z</published>
    <updated>2016-07-10T18:25:27.659Z</updated>
    
    <content type="html">&lt;p&gt;In this post I would share some of the things I came across when dealing with&lt;br&gt;the handling of joysticks and gamepads in Linux. One of the goals I wanted to&lt;br&gt;achieve was to make our controller mappings compatible with the SDL ones so that&lt;br&gt;we can reuse the community maintained controller mapping database that they have.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;The full code can be found &lt;a href=&quot;https://gist.github.com/meghprkh/9cdce0cd4e0f41ce93413b250a207a55&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The first thing that I want to clarify is that Linux provides &lt;em&gt;two&lt;/em&gt; APIs for&lt;br&gt;dealing with joysticks. One is the legacy &lt;em&gt;joystick&lt;/em&gt; API and the other is the&lt;br&gt;modern &lt;em&gt;evdev&lt;/em&gt; API. The evdev-based API provides more detailed information about&lt;br&gt;the buttons and axes available and SDL2 only supports the evdev API so we&lt;br&gt;decided to go with the evdev API.&lt;/p&gt;
&lt;p&gt;Quoting Arch Wiki:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;/dev/input/jsX&lt;/code&gt; maps to the ‘Joystick’ API interface and &lt;code&gt;/dev/input/event*&lt;/code&gt;&lt;br&gt;maps to the ‘evdev’ ones (this also includes other input devices such as mice&lt;br&gt;and keyboards). Symbolic links to those devices are also available in&lt;br&gt;&lt;code&gt;/dev/input/by-id/&lt;/code&gt; and &lt;code&gt;/dev/input/by-path/&lt;/code&gt; where the legacy ‘Joystick’ API&lt;br&gt;has names ending with -joystick while the ‘evdev’ have names ending with&lt;br&gt;&lt;code&gt;-event-joystick&lt;/code&gt;.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For using the evdev API, I decided to use the libevdev library instead of using traditional &lt;code&gt;ioctl&lt;/code&gt; calls as this library provided simpler higher-level access to the evdev API.&lt;/p&gt;
&lt;p&gt;Moving on to our main goal: we want to reuse the SDL mappings. The SDL mappings look something like these:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;guid,name,mappings&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;030000006d0400001dc2000014400000,Logitech F310 Gamepad (XInput),a:b0,b:b1,back:b6,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,dpup:h0.1,guide:b8,leftshoulder:b4,leftstick:b9,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b10,righttrigger:a5,rightx:a3,righty:a4,start:b7,x:b2,y:b3,&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Quoting SDL documentation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The mapping format for joystick is:&lt;br&gt;    bX - a joystick button, index X&lt;br&gt;    hX.Y - hat X with value Y&lt;br&gt;    aX - axis X of the joystick&lt;br&gt;Buttons can be used as a controller axis and vice versa.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this post we will assume that we will handle the parsing of this mapping and only need to get the indexes correctly (like &lt;code&gt;b0&lt;/code&gt;, &lt;code&gt;a2&lt;/code&gt;, etc.)&lt;/p&gt;
&lt;h2 id=&quot;Generating-GUID&quot;&gt;&lt;a href=&quot;#Generating-GUID&quot; class=&quot;headerlink&quot; title=&quot;Generating GUID&quot;&gt;&lt;/a&gt;Generating GUID&lt;/h2&gt;&lt;p&gt;So the first problem was to decipher how the GUID was generated. The GUID is an 128-bit code that is time and device independent. Its constructed using the bustype, vendor, product and version of the device. It is generated using the following code:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_guid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; libevdev * dev, guint16 * guid)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = GINT16_TO_LE(libevdev_get_id_bustype(dev));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = GINT16_TO_LE(libevdev_get_id_vendor(dev));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] = GINT16_TO_LE(libevdev_get_id_product(dev));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;] = GINT16_TO_LE(libevdev_get_id_version(dev));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    guid[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;As we want it to be device independent, we use the &lt;code&gt;GINT16_TO_LE&lt;/code&gt; helper from glib to convert a 16 bit number to little endian.&lt;/p&gt;
&lt;p&gt;But to convert this to string we convert it to its hexadecimal equivalent using the following simple code:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;guid_to_string&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(guint16 * guid, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * guidstr)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; k_rgchHexToASCII[] = &lt;span class=&quot;string&quot;&gt;&quot;0123456789abcdef&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c = guid[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        *guidstr++ = k_rgchHexToASCII[c &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        *guidstr++ = k_rgchHexToASCII[c &amp;amp; &lt;span class=&quot;number&quot;&gt;0x0F&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        c = guid[i] &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        *guidstr++ = k_rgchHexToASCII[c &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        *guidstr++ = k_rgchHexToASCII[c &amp;amp; &lt;span class=&quot;number&quot;&gt;0x0F&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *guidstr = &lt;span class=&quot;string&quot;&gt;&#39;\0&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Feature-Detection-and-mapping-to-the-SDL-indexes&quot;&gt;&lt;a href=&quot;#Feature-Detection-and-mapping-to-the-SDL-indexes&quot; class=&quot;headerlink&quot; title=&quot;Feature Detection and mapping to the SDL indexes&quot;&gt;&lt;/a&gt;Feature Detection and mapping to the SDL indexes&lt;/h2&gt;&lt;p&gt;Now coming to the feature detection part. We use the helper &lt;code&gt;libevdev_has_event_code (dev, type, code)&lt;/code&gt; to detect if the device has a button/axis/hat. This way we loop over the possible values of the code for each type (&lt;code&gt;EV_KEY&lt;/code&gt; for button, &lt;code&gt;EV_ABS&lt;/code&gt; for axes and hat) and map it to an increasing number. That is the first valid axis code we found is &lt;code&gt;axis0&lt;/code&gt; or &lt;code&gt;a0&lt;/code&gt;, the second valid axis is &lt;code&gt;a1&lt;/code&gt; and so on. It is the same for buttons.&lt;/p&gt;
&lt;p&gt;For example, following is part of the code for buttons:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nbuttons = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;guint8 key_map[KEY_MAX];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = BTN_JOYSTICK; i &amp;lt; KEY_MAX; ++i) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (libevdev_has_event_code(dev, EV_KEY, i)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d - Joystick has button: 0x%x - %s\n&quot;&lt;/span&gt;, nbuttons, i,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                libevdev_event_code_get_name(EV_KEY, i));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        key_map[i - BTN_MISC] = nbuttons;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ++nbuttons;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;And while polling we find the button number through this &lt;code&gt;key_map&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Button %d\n&quot;&lt;/span&gt;, key_map[ev.code - BTN_MISC]);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;We do similar stuff for axes and hats even though the way we map changes. The hats mapping like &lt;code&gt;h0.4&lt;/code&gt; can be done using a simple map from code and value. But SDL returns output as a 8-way dpad giving one of the eight values (like up, leftup, etc.) while evdev gives hat as two axes and reports two events: left and up on pressing the dpad/hat in the leftup direction.&lt;/p&gt;
&lt;h2 id=&quot;Conclusion&quot;&gt;&lt;a href=&quot;#Conclusion&quot; class=&quot;headerlink&quot; title=&quot;Conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;For polling events we use the &lt;code&gt;libevdev_next_event&lt;/code&gt; function. The full &lt;strong&gt;libevdev documentation&lt;/strong&gt; can be found &lt;a href=&quot;https://www.freedesktop.org/software/libevdev/doc/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;full code&lt;/strong&gt; can be found &lt;a href=&quot;https://gist.github.com/meghprkh/9cdce0cd4e0f41ce93413b250a207a55&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;here&lt;/a&gt;. While this code uses glib, it only uses simple helper functions from glib which can be easily reimplemented. The only complex glib functions used are to detect the event-joystick device from the &lt;code&gt;/dev/input/by-path&lt;/code&gt; folder. This code also doesnot have several fallbacks that the SDL code has.&lt;/p&gt;
&lt;p&gt;My future work will involve the integration of this ‘playground’ code into the main GNOME Games code and also parsing the mapping. Other things that need to be done is to handle hats properly, handle fallbacks and see if we want to detect joystick devices by polling only or use udev.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In this post I would share some of the things I came across when dealing with&lt;br&gt;the handling of joysticks and gamepads in Linux. One of the goals I wanted to&lt;br&gt;achieve was to make our controller mappings compatible with the SDL ones so that&lt;br&gt;we can reuse the community maintained controller mapping database that they have.&lt;/p&gt;
    
    </summary>
    
      <category term="Opensource" scheme="https://meghprkh.github.io/blog/categories/Opensource/"/>
    
    
      <category term="GNOME" scheme="https://meghprkh.github.io/blog/tags/GNOME/"/>
    
      <category term="GSoC" scheme="https://meghprkh.github.io/blog/tags/GSoC/"/>
    
      <category term="Gamepad" scheme="https://meghprkh.github.io/blog/tags/Gamepad/"/>
    
      <category term="Linux" scheme="https://meghprkh.github.io/blog/tags/Linux/"/>
    
      <category term="Joystick" scheme="https://meghprkh.github.io/blog/tags/Joystick/"/>
    
  </entry>
  
  <entry>
    <title>GSoC 2016: Introduction</title>
    <link href="https://meghprkh.github.io/blog/2016/05/23/GSoC-2016-Introduction/"/>
    <id>https://meghprkh.github.io/blog/2016/05/23/GSoC-2016-Introduction/</id>
    <published>2016-05-23T12:19:03.000Z</published>
    <updated>2016-07-10T18:25:27.659Z</updated>
    
    <content type="html">&lt;p&gt;Hello everyone, I am participating in Google Summer Of Code 2016 under the GNOME project.&lt;/p&gt;
&lt;p&gt;My project is related to an application called &lt;a href=&quot;https://wiki.gnome.org/Apps/Games/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GNOME Games&lt;/a&gt;. As you can see this app serves as an catalog of games alongside an emulator. My proposal is related to adding support for gamepads/joysticks/controllers to this app. By this I mean the ability to play emulated games using the gamepad.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;This proposal has plans for adding support for remappabale controls and multiple gamepads (for multi-player games). This would come with an easy to use UI.&lt;/p&gt;
&lt;p&gt;Also other stretch goals include the ability to control the “Games UI” itself using the gamepad as well as making the code reusable so that it can be used as a library. Some other stretch goals involve moving the gamepad configuration UI to control center as well as having gamepad support for the GNOME games pack itself (will start with Nibbles).&lt;/p&gt;
&lt;p&gt;Looking forward to having a great summer wherein I will put my full potential into developing this ideas with the aid of my mentor &lt;a href=&quot;https://wiki.gnome.org/AdrienPlazas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Adrien Plazas&lt;/a&gt;. I will regularly post updates here.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Hello everyone, I am participating in Google Summer Of Code 2016 under the GNOME project.&lt;/p&gt;
&lt;p&gt;My project is related to an application called &lt;a href=&quot;https://wiki.gnome.org/Apps/Games/&quot;&gt;GNOME Games&lt;/a&gt;. As you can see this app serves as an catalog of games alongside an emulator. My proposal is related to adding support for gamepads/joysticks/controllers to this app. By this I mean the ability to play emulated games using the gamepad.&lt;/p&gt;
    
    </summary>
    
      <category term="Opensource" scheme="https://meghprkh.github.io/blog/categories/Opensource/"/>
    
    
      <category term="GNOME" scheme="https://meghprkh.github.io/blog/tags/GNOME/"/>
    
      <category term="GSoC" scheme="https://meghprkh.github.io/blog/tags/GSoC/"/>
    
  </entry>
  
  <entry>
    <title>Creating an RPM package for a PHP PEAR module</title>
    <link href="https://meghprkh.github.io/blog/2014/12/17/Creating-an-RPM-package-for-a-PHP-PEAR-module/"/>
    <id>https://meghprkh.github.io/blog/2014/12/17/Creating-an-RPM-package-for-a-PHP-PEAR-module/</id>
    <published>2014-12-17T06:49:38.000Z</published>
    <updated>2016-07-10T18:25:27.659Z</updated>
    
    <content type="html">&lt;p&gt;I am participating in Google Code In 2014 and two of my tasks were based on RPM packaging for Fedora.&lt;br&gt;&lt;a href=&quot;http://www.google-melange.com/gci/task/view/google/gci2014/5262603731337216&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The first&lt;/a&gt; was packaging &lt;a href=&quot;http://www.phalconphp.com/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PhalconPHP&lt;/a&gt; for Fedora while &lt;a href=&quot;http://www.google-melange.com/gci/task/view/google/gci2014/5774064475963392&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;the second&lt;/a&gt; was packaging &lt;a href=&quot;http://cakephp.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CakePHP&lt;/a&gt;.&lt;br&gt;Phalcon is an C extension while Cake is a PEAR/Composer extension.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;I will discuss the easier of the two, Cake as it was a PEAR package.&lt;/p&gt;
&lt;p&gt;So first of all, you need to learn some RPM Packaging Basics. &lt;a href=&quot;https://fedoraproject.org/wiki/How_to_create_an_RPM_package&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;This link&lt;/a&gt; briefly introduces us to the necessary tools and their setup. But the above link does not introduce us to &lt;a href=&quot;http://copr.fedoraproject.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Copr&lt;/a&gt; which may be used to distribute and even build our RPMS on different platforms (we can use it as a sort of substitute for &lt;a href=&quot;https://fedoraproject.org/wiki/How_to_create_an_RPM_package#Mock_and_Koji&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Koji or Mock&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Then I recommend that you read &lt;a href=&quot;[http://fedoraproject.org/wiki/Packaging](http://fedoraproject.org/wiki/Packaging&quot;&gt;PHP Packaging wiki&lt;/a&gt;:&lt;/p&gt;
&lt;h2 id=&quot;The-Channel-package&quot;&gt;&lt;a href=&quot;#The-Channel-package&quot; class=&quot;headerlink&quot; title=&quot;The Channel package&quot;&gt;&lt;/a&gt;The Channel package&lt;/h2&gt;&lt;p&gt;So lets say we have identified the PEAR channel (pear.example.org) and it is not the standard PEAR channel. So we need to create a CHANNEL package.&lt;/p&gt;
&lt;p&gt;So lets create the SPEC file :&lt;br&gt;&lt;script src=&quot;//gist.github.com/meghprkh/066d9477881f168c77b4.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;As you can see you just need to edit a few lines (lines 2,3) to update the channel name and URL and the last lines for proper changelogs.&lt;/p&gt;
&lt;p&gt;Now you can build this spec using the &lt;code&gt;rpmbuild&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;Install the generated RPM on your system (provided the build is successful).&lt;/p&gt;
&lt;h2 id=&quot;The-PEAR-Package&quot;&gt;&lt;a href=&quot;#The-PEAR-Package&quot; class=&quot;headerlink&quot; title=&quot;The PEAR Package&quot;&gt;&lt;/a&gt;The PEAR Package&lt;/h2&gt;&lt;p&gt;Now lets head on to creating the actual SPEC file of the RPM package.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First install the &lt;code&gt;php-pear-PEAR-Command-Packaging&lt;/code&gt; package.&lt;/li&gt;
&lt;li&gt;Download the PEAR package from the channel (mostly &lt;em&gt;&lt;a href=&quot;http://channelname/get/name-version.tgz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://channelname/get/name-version.tgz&lt;/a&gt;&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;pear make-rpm-spec Foo.tgz&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;and a spec file will be generated for you (with all required files) …&lt;/li&gt;
&lt;li&gt;… but if it is not from the standard PEAR channel, you will need to add the channel to the requires and modify certain lines …&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;You may look at &lt;a href=&quot;https://gist.github.com/meghprkh/39fa65e683f36a4b3996&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;my spec for CakePHP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Done now You just need to build it …&lt;/li&gt;
&lt;li&gt;If the build fails make sure you had installed the Channel Package&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;%global pear_name example&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%global pear_channel pear.example.org&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;URL:            http://%&amp;#123;pear_channel&amp;#125;/package/%&amp;#123;pear_name&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Source0:        http://%&amp;#123;pear_channel&amp;#125;/get/%&amp;#123;pear_name&amp;#125;-%&amp;#123;version&amp;#125;.tgz&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;BuildRequires:  php-channel(%&amp;#123;pear_channel&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Requires:       php-channel(%&amp;#123;pear_channel&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;The-Copr-Build-System&quot;&gt;&lt;a href=&quot;#The-Copr-Build-System&quot; class=&quot;headerlink&quot; title=&quot;The Copr Build System&quot;&gt;&lt;/a&gt;The Copr Build System&lt;/h2&gt;&lt;p&gt;Lets say you have Fedora 20 on your system but you also want to build it for other Fedora and EPEL versions and also make the installation simpler for the end user. So the right tool you need to use is the &lt;a href=&quot;http://copr.fedoraproject.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Copr&lt;/a&gt; Build System.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upload your SRPMs to some file sharing service which permits direct downloads through a link (I used GitHub but thats a bad habit for git is extremely slow with binary files (SRPMS are gzipped files)).&lt;/li&gt;
&lt;li&gt;Go to the Copr build system page.&lt;/li&gt;
&lt;li&gt;Read their wiki a little.&lt;/li&gt;
&lt;li&gt;Login and create a new repo&lt;/li&gt;
&lt;li&gt;First build the Channel package in your repo&lt;/li&gt;
&lt;li&gt;Drink some coffee. Its gonna take some time.&lt;/li&gt;
&lt;li&gt;Next build the PEAR package (build it after the first completes for it is dependent onthe channel package)&lt;/li&gt;
&lt;li&gt;Share your work.&lt;/li&gt;
&lt;li&gt;You may see my repo for &lt;a href=&quot;https://copr.fedoraproject.org/coprs/meghprkh/cakephp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy and paste installation instructions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;I am participating in Google Code In 2014 and two of my tasks were based on RPM packaging for Fedora.&lt;br&gt;&lt;a href=&quot;http://www.google-melange.com/gci/task/view/google/gci2014/5262603731337216&quot;&gt;The first&lt;/a&gt; was packaging &lt;a href=&quot;http://www.phalconphp.com/en/&quot;&gt;PhalconPHP&lt;/a&gt; for Fedora while &lt;a href=&quot;http://www.google-melange.com/gci/task/view/google/gci2014/5774064475963392&quot;&gt;the second&lt;/a&gt; was packaging &lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt;.&lt;br&gt;Phalcon is an C extension while Cake is a PEAR/Composer extension.&lt;/p&gt;
    
    </summary>
    
      <category term="Opensource" scheme="https://meghprkh.github.io/blog/categories/Opensource/"/>
    
    
      <category term="Fedora" scheme="https://meghprkh.github.io/blog/tags/Fedora/"/>
    
      <category term="Packaging" scheme="https://meghprkh.github.io/blog/tags/Packaging/"/>
    
  </entry>
  
</feed>
