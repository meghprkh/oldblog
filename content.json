{"meta":{"title":"Megh's Blog","subtitle":null,"description":null,"author":"Megh Parikh","url":"https://meghprkh.github.io/blog"},"pages":[{"title":"About","date":"2016-07-10T18:25:27.659Z","updated":"2016-07-10T18:25:27.659Z","comments":false,"path":"about/index.html","permalink":"https://meghprkh.github.io/blog/about/index.html","excerpt":"","text":"Hello, I am Megh. I am a web developer who loves using ReactJS and other FRP concepts. In my free time I like to contribute to things that I use - especially GNOME. I offer my web development services on freelance basis. You can hire me via Freelancer.com I also love solving Math &amp; Physics problems and playing puzzle/strategy games. Currently I study Computer Science &amp; Engineering at IIIT, Hyderabad. You can contact me via my site or my github profile"},{"title":"Categories","date":"2016-07-10T18:25:27.659Z","updated":"2016-07-10T18:25:27.659Z","comments":true,"path":"categories/index.html","permalink":"https://meghprkh.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-07-10T18:25:27.659Z","updated":"2016-07-10T18:25:27.659Z","comments":true,"path":"tags/index.html","permalink":"https://meghprkh.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Adventures with the Meson Build System and a GTK Playground","slug":"Adventures-with-the-Meson-Build-System-and-a-GTK-Playground","date":"2016-07-10T19:30:04.000Z","updated":"2016-07-10T19:48:31.074Z","comments":true,"path":"2016/07/11/Adventures-with-the-Meson-Build-System-and-a-GTK-Playground/","link":"","permalink":"https://meghprkh.github.io/blog/blog/2016/07/11/Adventures-with-the-Meson-Build-System-and-a-GTK-Playground/","excerpt":"This post describes some of my experience with the Meson Build system. Also I have created a playground for GTK which I use to create simple protoypes with some functionality. The really nice thing about Meson is its python-ish/lua-ish syntax. The other thing is that it is really fast.","text":"This post describes some of my experience with the Meson Build system. Also I have created a playground for GTK which I use to create simple protoypes with some functionality. The really nice thing about Meson is its python-ish/lua-ish syntax. The other thing is that it is really fast. My experienceAs a newbie I found Automake unfriendly (maybe because of its primitive m4 macro system). So I was looking for something quick to learn for building my LibGamepad library. Initially I opted for the awesome Autovala. But then I realized that while super-easy, it was not flexible. I wanted conditional compilation (per-platform) but could not do it. Then while I was looking at the CMake files generated by Autovala, they too felt kind of cryptic, so I decided to start from scratch and write the CMake files on my own. Still even CMake’s syntax was kind of weird and macro-ish. Then I tried a hand at Meson. Surprisingly I was able to easily build simple Vala programs without giving it much time. The neat languageIn Meson, you feel like you are interacting with a higher-order language. You get immutable arrays and strings. Your interaction with the compiler modules is through objects. In short, its just amazing. I could have elaborated this section and written some features, but then you can find it on the Meson Wiki. Some reference links Tutorial: https://github.com/mesonbuild/meson/wiki/Tutorial Indepth Tutorial: https://github.com/mesonbuild/meson/wiki/IndepthTutorial Vala example: https://github.com/mesonbuild/meson/wiki/Vala GNOME module: https://github.com/mesonbuild/meson/wiki/Gnome-module Reference Manual: https://github.com/mesonbuild/meson/wiki/Reference-Manual Note: On Fedora it is ninja-build and not ninja A GTK Playground / A starter kitEver want to prototype some mockup without fiddling with your main application? I created a small playground which I use for creating prototypes https://github.com/meghprkh/valagtk . You can simply open Glade, create your prototype and add some interactivity using GtkTemplate in your Vala code and BOOM! This uses the Meson build system to give you an easy-to-extend starter along with super-fast builds. Please leave your comments in the comments section =).","categories":[{"name":"Opensource","slug":"Opensource","permalink":"https://meghprkh.github.io/blog/categories/Opensource/"}],"tags":[{"name":"GNOME","slug":"GNOME","permalink":"https://meghprkh.github.io/blog/tags/GNOME/"},{"name":"Meson Build","slug":"Meson-Build","permalink":"https://meghprkh.github.io/blog/tags/Meson-Build/"}]},{"title":"GSoC - Progress so far","slug":"GSoC-Progress-so-far","date":"2016-06-26T13:28:22.000Z","updated":"2016-07-10T18:25:27.659Z","comments":true,"path":"2016/06/26/GSoC-Progress-so-far/","link":"","permalink":"https://meghprkh.github.io/blog/blog/2016/06/26/GSoC-Progress-so-far/","excerpt":"My project is about adding gamepad support to GNOME Games. This means that soon you would be able to play your favorite retro games using a gamepad! Currently you can plugin a gamepad and it will just work! The app will automatically detect it and allow you to play your favorite game using the gamepad. Support for playing multiplayer games is also there. The Games branch which supports gamepads can be found here.","text":"My project is about adding gamepad support to GNOME Games. This means that soon you would be able to play your favorite retro games using a gamepad! Currently you can plugin a gamepad and it will just work! The app will automatically detect it and allow you to play your favorite game using the gamepad. Support for playing multiplayer games is also there. The Games branch which supports gamepads can be found here. How its being doneTo integrate gamepads a library was made. While currently this library is being developed as part of the GNOME Games codebase. Its developed under a different namespace. You can find the library code here. Please note that the API of this library is unstable and will keep changing. This library is a small GLib-based library that is written in Vala and aims to be easy to use. While the long-term goal is to be cross-platform, currently it supports Linux only. The gamepad mapping format used is compatible with the SDL mappings. This means that you would be able to use many gamepads without requiring to configure them. What’s there in the future?After some more cleanup, this code will hopefully be merged into the Games codebase. After that I will focus on adding UI for features like easy-assigning of gamepads to ports and remapping the gamepad. I will keep posting updates on this blog. Stay tuned! Related posts GSoC 2016: Introduction Handling joysticks and gamepads in linux","categories":[{"name":"Opensource","slug":"Opensource","permalink":"https://meghprkh.github.io/blog/categories/Opensource/"}],"tags":[{"name":"GNOME","slug":"GNOME","permalink":"https://meghprkh.github.io/blog/tags/GNOME/"},{"name":"GSoC","slug":"GSoC","permalink":"https://meghprkh.github.io/blog/tags/GSoC/"},{"name":"Gamepad","slug":"Gamepad","permalink":"https://meghprkh.github.io/blog/tags/Gamepad/"},{"name":"Library","slug":"Library","permalink":"https://meghprkh.github.io/blog/tags/Library/"},{"name":"Games","slug":"Games","permalink":"https://meghprkh.github.io/blog/tags/Games/"},{"name":"GNOME Games","slug":"GNOME-Games","permalink":"https://meghprkh.github.io/blog/tags/GNOME-Games/"}]},{"title":"Handling joysticks and gamepads in linux","slug":"Handling-joysticks-and-gamepads-in-linux","date":"2016-06-03T16:58:52.000Z","updated":"2016-07-10T18:25:27.659Z","comments":true,"path":"2016/06/03/Handling-joysticks-and-gamepads-in-linux/","link":"","permalink":"https://meghprkh.github.io/blog/blog/2016/06/03/Handling-joysticks-and-gamepads-in-linux/","excerpt":"In this post I would share some of the things I came across when dealing withthe handling of joysticks and gamepads in Linux. One of the goals I wanted toachieve was to make our controller mappings compatible with the SDL ones so thatwe can reuse the community maintained controller mapping database that they have.","text":"In this post I would share some of the things I came across when dealing withthe handling of joysticks and gamepads in Linux. One of the goals I wanted toachieve was to make our controller mappings compatible with the SDL ones so thatwe can reuse the community maintained controller mapping database that they have. The full code can be found here. The first thing that I want to clarify is that Linux provides two APIs fordealing with joysticks. One is the legacy joystick API and the other is themodern evdev API. The evdev-based API provides more detailed information aboutthe buttons and axes available and SDL2 only supports the evdev API so wedecided to go with the evdev API. Quoting Arch Wiki: /dev/input/jsX maps to the ‘Joystick’ API interface and /dev/input/event*maps to the ‘evdev’ ones (this also includes other input devices such as miceand keyboards). Symbolic links to those devices are also available in/dev/input/by-id/ and /dev/input/by-path/ where the legacy ‘Joystick’ APIhas names ending with -joystick while the ‘evdev’ have names ending with-event-joystick. For using the evdev API, I decided to use the libevdev library instead of using traditional ioctl calls as this library provided simpler higher-level access to the evdev API. Moving on to our main goal: we want to reuse the SDL mappings. The SDL mappings look something like these:12&quot;guid,name,mappings&quot;&quot;030000006d0400001dc2000014400000,Logitech F310 Gamepad (XInput),a:b0,b:b1,back:b6,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,dpup:h0.1,guide:b8,leftshoulder:b4,leftstick:b9,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b10,righttrigger:a5,rightx:a3,righty:a4,start:b7,x:b2,y:b3,&quot; Quoting SDL documentation: The mapping format for joystick is: bX - a joystick button, index X hX.Y - hat X with value Y aX - axis X of the joystickButtons can be used as a controller axis and vice versa. In this post we will assume that we will handle the parsing of this mapping and only need to get the indexes correctly (like b0, a2, etc.) Generating GUIDSo the first problem was to decipher how the GUID was generated. The GUID is an 128-bit code that is time and device independent. Its constructed using the bustype, vendor, product and version of the device. It is generated using the following code: 12345678910void get_guid(struct libevdev * dev, guint16 * guid) &#123; guid[0] = GINT16_TO_LE(libevdev_get_id_bustype(dev)); guid[1] = 0; guid[2] = GINT16_TO_LE(libevdev_get_id_vendor(dev)); guid[3] = 0; guid[4] = GINT16_TO_LE(libevdev_get_id_product(dev)); guid[5] = 0; guid[6] = GINT16_TO_LE(libevdev_get_id_version(dev)); guid[7] = 0;&#125; As we want it to be device independent, we use the GINT16_TO_LE helper from glib to convert a 16 bit number to little endian. But to convert this to string we convert it to its hexadecimal equivalent using the following simple code: 123456789101112131415void guid_to_string(guint16 * guid, char * guidstr) &#123; static const char k_rgchHexToASCII[] = \"0123456789abcdef\"; int i; for (i = 0; i &lt; 8; i++) &#123; unsigned char c = guid[i]; *guidstr++ = k_rgchHexToASCII[c &gt;&gt; 4]; *guidstr++ = k_rgchHexToASCII[c &amp; 0x0F]; c = guid[i] &gt;&gt; 8; *guidstr++ = k_rgchHexToASCII[c &gt;&gt; 4]; *guidstr++ = k_rgchHexToASCII[c &amp; 0x0F]; &#125; *guidstr = '\\0';&#125; Feature Detection and mapping to the SDL indexesNow coming to the feature detection part. We use the helper libevdev_has_event_code (dev, type, code) to detect if the device has a button/axis/hat. This way we loop over the possible values of the code for each type (EV_KEY for button, EV_ABS for axes and hat) and map it to an increasing number. That is the first valid axis code we found is axis0 or a0, the second valid axis is a1 and so on. It is the same for buttons. For example, following is part of the code for buttons:12345678910int nbuttons = 0;guint8 key_map[KEY_MAX];for (i = BTN_JOYSTICK; i &lt; KEY_MAX; ++i) &#123; if (libevdev_has_event_code(dev, EV_KEY, i)) &#123; printf(\"%d - Joystick has button: 0x%x - %s\\n\", nbuttons, i, libevdev_event_code_get_name(EV_KEY, i)); key_map[i - BTN_MISC] = nbuttons; ++nbuttons; &#125;&#125; And while polling we find the button number through this key_map:1printf(\"Button %d\\n\", key_map[ev.code - BTN_MISC]); We do similar stuff for axes and hats even though the way we map changes. The hats mapping like h0.4 can be done using a simple map from code and value. But SDL returns output as a 8-way dpad giving one of the eight values (like up, leftup, etc.) while evdev gives hat as two axes and reports two events: left and up on pressing the dpad/hat in the leftup direction. ConclusionFor polling events we use the libevdev_next_event function. The full libevdev documentation can be found here The full code can be found here. While this code uses glib, it only uses simple helper functions from glib which can be easily reimplemented. The only complex glib functions used are to detect the event-joystick device from the /dev/input/by-path folder. This code also doesnot have several fallbacks that the SDL code has. My future work will involve the integration of this ‘playground’ code into the main GNOME Games code and also parsing the mapping. Other things that need to be done is to handle hats properly, handle fallbacks and see if we want to detect joystick devices by polling only or use udev.","categories":[{"name":"Opensource","slug":"Opensource","permalink":"https://meghprkh.github.io/blog/categories/Opensource/"}],"tags":[{"name":"GNOME","slug":"GNOME","permalink":"https://meghprkh.github.io/blog/tags/GNOME/"},{"name":"GSoC","slug":"GSoC","permalink":"https://meghprkh.github.io/blog/tags/GSoC/"},{"name":"Gamepad","slug":"Gamepad","permalink":"https://meghprkh.github.io/blog/tags/Gamepad/"},{"name":"Linux","slug":"Linux","permalink":"https://meghprkh.github.io/blog/tags/Linux/"},{"name":"Joystick","slug":"Joystick","permalink":"https://meghprkh.github.io/blog/tags/Joystick/"}]},{"title":"GSoC 2016: Introduction","slug":"GSoC-2016-Introduction","date":"2016-05-23T12:19:03.000Z","updated":"2016-07-10T18:25:27.659Z","comments":true,"path":"2016/05/23/GSoC-2016-Introduction/","link":"","permalink":"https://meghprkh.github.io/blog/blog/2016/05/23/GSoC-2016-Introduction/","excerpt":"Hello everyone, I am participating in Google Summer Of Code 2016 under the GNOME project. My project is related to an application called GNOME Games. As you can see this app serves as an catalog of games alongside an emulator. My proposal is related to adding support for gamepads/joysticks/controllers to this app. By this I mean the ability to play emulated games using the gamepad.","text":"Hello everyone, I am participating in Google Summer Of Code 2016 under the GNOME project. My project is related to an application called GNOME Games. As you can see this app serves as an catalog of games alongside an emulator. My proposal is related to adding support for gamepads/joysticks/controllers to this app. By this I mean the ability to play emulated games using the gamepad. This proposal has plans for adding support for remappabale controls and multiple gamepads (for multi-player games). This would come with an easy to use UI. Also other stretch goals include the ability to control the “Games UI” itself using the gamepad as well as making the code reusable so that it can be used as a library. Some other stretch goals involve moving the gamepad configuration UI to control center as well as having gamepad support for the GNOME games pack itself (will start with Nibbles). Looking forward to having a great summer wherein I will put my full potential into developing this ideas with the aid of my mentor Adrien Plazas. I will regularly post updates here.","categories":[{"name":"Opensource","slug":"Opensource","permalink":"https://meghprkh.github.io/blog/categories/Opensource/"}],"tags":[{"name":"GNOME","slug":"GNOME","permalink":"https://meghprkh.github.io/blog/tags/GNOME/"},{"name":"GSoC","slug":"GSoC","permalink":"https://meghprkh.github.io/blog/tags/GSoC/"}]},{"title":"Creating an RPM package for a PHP PEAR module","slug":"Creating-an-RPM-package-for-a-PHP-PEAR-module","date":"2014-12-17T06:49:38.000Z","updated":"2016-07-10T18:25:27.659Z","comments":true,"path":"2014/12/17/Creating-an-RPM-package-for-a-PHP-PEAR-module/","link":"","permalink":"https://meghprkh.github.io/blog/blog/2014/12/17/Creating-an-RPM-package-for-a-PHP-PEAR-module/","excerpt":"I am participating in Google Code In 2014 and two of my tasks were based on RPM packaging for Fedora.The first was packaging PhalconPHP for Fedora while the second was packaging CakePHP.Phalcon is an C extension while Cake is a PEAR/Composer extension.","text":"I am participating in Google Code In 2014 and two of my tasks were based on RPM packaging for Fedora.The first was packaging PhalconPHP for Fedora while the second was packaging CakePHP.Phalcon is an C extension while Cake is a PEAR/Composer extension. I will discuss the easier of the two, Cake as it was a PEAR package. So first of all, you need to learn some RPM Packaging Basics. This link briefly introduces us to the necessary tools and their setup. But the above link does not introduce us to Copr which may be used to distribute and even build our RPMS on different platforms (we can use it as a sort of substitute for Koji or Mock). Then I recommend that you read PHP Packaging wiki: The Channel packageSo lets say we have identified the PEAR channel (pear.example.org) and it is not the standard PEAR channel. So we need to create a CHANNEL package. So lets create the SPEC file : As you can see you just need to edit a few lines (lines 2,3) to update the channel name and URL and the last lines for proper changelogs. Now you can build this spec using the rpmbuild command. Install the generated RPM on your system (provided the build is successful). The PEAR PackageNow lets head on to creating the actual SPEC file of the RPM package. First install the php-pear-PEAR-Command-Packaging package. Download the PEAR package from the channel (mostly http://channelname/get/name-version.tgz) Run pear make-rpm-spec Foo.tgz . and a spec file will be generated for you (with all required files) … … but if it is not from the standard PEAR channel, you will need to add the channel to the requires and modify certain lines … You may look at my spec for CakePHP Done now You just need to build it … If the build fails make sure you had installed the Channel Package 123456%global pear_name example%global pear_channel pear.example.orgURL: http://%&#123;pear_channel&#125;/package/%&#123;pear_name&#125;Source0: http://%&#123;pear_channel&#125;/get/%&#123;pear_name&#125;-%&#123;version&#125;.tgzBuildRequires: php-channel(%&#123;pear_channel&#125;)Requires: php-channel(%&#123;pear_channel&#125;) The Copr Build SystemLets say you have Fedora 20 on your system but you also want to build it for other Fedora and EPEL versions and also make the installation simpler for the end user. So the right tool you need to use is the Copr Build System. Upload your SRPMs to some file sharing service which permits direct downloads through a link (I used GitHub but thats a bad habit for git is extremely slow with binary files (SRPMS are gzipped files)). Go to the Copr build system page. Read their wiki a little. Login and create a new repo First build the Channel package in your repo Drink some coffee. Its gonna take some time. Next build the PEAR package (build it after the first completes for it is dependent onthe channel package) Share your work. You may see my repo for copy and paste installation instructions","categories":[{"name":"Opensource","slug":"Opensource","permalink":"https://meghprkh.github.io/blog/categories/Opensource/"}],"tags":[{"name":"Fedora","slug":"Fedora","permalink":"https://meghprkh.github.io/blog/tags/Fedora/"},{"name":"Packaging","slug":"Packaging","permalink":"https://meghprkh.github.io/blog/tags/Packaging/"}]}]}